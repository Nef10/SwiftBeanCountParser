// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: beancount/cparser/options.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// -*- mode: protobuf -*-
//
// A schema for Beancount's options. This is produced by the parser and provided
// for plugin writers to use.
//
// Note: There is no support for options names aliases here.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A set of valid booking method names for positions on accounts.
/// See http://furius.ca/beancount/doc/inventories for a full explanation.
enum Beancount_Options_Booking: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// Reject ambiguous matches with an error.
  case strict // = 1

  /// Reject ambiguous matches with an error but if a
  case strictWithSize // = 2

  /// lot matches the size exactly, accept it the oldest.
  case none // = 3

  /// Average cost booking: merge all matching lots before and after.
  case average // = 4

  /// First-in first-out in the case of ambiguity.
  case fifo // = 5

  /// Last-in first-out in the case of ambiguity.
  case lifo // = 6

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .strict
    case 2: self = .strictWithSize
    case 3: self = .none
    case 4: self = .average
    case 5: self = .fifo
    case 6: self = .lifo
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .strict: return 1
    case .strictWithSize: return 2
    case .none: return 3
    case .average: return 4
    case .fifo: return 5
    case .lifo: return 6
    }
  }

}

#if swift(>=4.2)

extension Beancount_Options_Booking: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Data produced as a by-product of the parsing process. This is essentially
/// read-only state that is conceptually separate from the input options,
/// produced by the parser.
struct Beancount_Options_ProcessingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the top-level Beancount input file parsed from which the
  /// contents of the ledger have been extracted. This may be None, if no file
  /// was used.
  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  /// A list of other filenames included. This is output from the parser and
  /// processed by the loader but the list should otherwise have been cleared by
  /// the time it gets to the top-level loader.load_*() function that invoked it.
  /// The filenames are absolute. Relative include filenames are resolved against
  /// the file that contains the include directives.
  ///
  /// This is used in the parser, but also, the loader sets this list to the
  /// full list of parsed absolute filenames in the options map. This is how you
  /// can find out the entire list of files involved in a Beancount load
  /// procedure.
  var include: [String] = []

  /// A hash of some of the input data. This is used to supplement the timestamps
  /// of the input files for the purpose of load caching. We typically hash the
  /// sizes of the files or perhaps even some of the contents, or determine any
  /// of the inputs have changed beyond the timestamps of the input files.
  /// (Internal use only; do not rely on this.)
  var inputHash: String {
    get {return _inputHash ?? String()}
    set {_inputHash = newValue}
  }
  /// Returns true if `inputHash` has been explicitly set.
  var hasInputHash: Bool {return self._inputHash != nil}
  /// Clears the value of `inputHash`. Subsequent reads from it will return its default value.
  mutating func clearInputHash() {self._inputHash = nil}

  /// Computed processing stats, that can be used to initialize a number
  /// formatter.
  var precisionStats: Beancount_Precision_PrecisionStats {
    get {return _precisionStats ?? Beancount_Precision_PrecisionStats()}
    set {_precisionStats = newValue}
  }
  /// Returns true if `precisionStats` has been explicitly set.
  var hasPrecisionStats: Bool {return self._precisionStats != nil}
  /// Clears the value of `precisionStats`. Subsequent reads from it will return its default value.
  mutating func clearPrecisionStats() {self._precisionStats = nil}

  /// A set of all the commodities that we have seen in the file. This is mainly
  /// used for efficiency, best computed once at parse time.
  var commodities: [String] = []

  var plugin: [Beancount_Options_ProcessingInfo.Plugin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A list of Python modules containing transformation functions to run the
  /// entries through after parsing. The parser reads the entries as they are,
  /// transforms them through a list of standard functions, such as balance
  /// checks and inserting padding entries, and then hands the entries over to
  /// those plugins to add more auto-generated goodies. The list is a list of
  /// pairs/tuples, in the format (plugin-name, plugin-configuration). The
  /// plugin-name should be the name of a Python module to import, and within the
  /// module we expect a special '__plugins__' attribute that should list the
  /// name of transform functions to run the entries through. The
  /// plugin-configuration argument is an optional string to be provided by the
  /// user. Each function accepts a pair of (entries, options_map) and should
  /// return a pair of (new entries, error instances). If a plugin configuration
  /// is provided, it is provided as an extra argument to the plugin function.
  /// Errors should not be printed out the output, they will be converted to
  /// strings by the loader and displayed as dictated by the output medium.
  struct Plugin {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    /// Configuration, most typically as a text-formatted protobuf message.
    var config: String {
      get {return _config ?? String()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    var hasConfig: Bool {return self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    mutating func clearConfig() {self._config = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _config: String? = nil
  }

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _inputHash: String? = nil
  fileprivate var _precisionStats: Beancount_Precision_PrecisionStats? = nil
}

/// Container for account types.
struct Beancount_Options_AccountTypes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assets: String {
    get {return _assets ?? String()}
    set {_assets = newValue}
  }
  /// Returns true if `assets` has been explicitly set.
  var hasAssets: Bool {return self._assets != nil}
  /// Clears the value of `assets`. Subsequent reads from it will return its default value.
  mutating func clearAssets() {self._assets = nil}

  var liabilities: String {
    get {return _liabilities ?? String()}
    set {_liabilities = newValue}
  }
  /// Returns true if `liabilities` has been explicitly set.
  var hasLiabilities: Bool {return self._liabilities != nil}
  /// Clears the value of `liabilities`. Subsequent reads from it will return its default value.
  mutating func clearLiabilities() {self._liabilities = nil}

  var equity: String {
    get {return _equity ?? String()}
    set {_equity = newValue}
  }
  /// Returns true if `equity` has been explicitly set.
  var hasEquity: Bool {return self._equity != nil}
  /// Clears the value of `equity`. Subsequent reads from it will return its default value.
  mutating func clearEquity() {self._equity = nil}

  var income: String {
    get {return _income ?? String()}
    set {_income = newValue}
  }
  /// Returns true if `income` has been explicitly set.
  var hasIncome: Bool {return self._income != nil}
  /// Clears the value of `income`. Subsequent reads from it will return its default value.
  mutating func clearIncome() {self._income = nil}

  var expenses: String {
    get {return _expenses ?? String()}
    set {_expenses = newValue}
  }
  /// Returns true if `expenses` has been explicitly set.
  var hasExpenses: Bool {return self._expenses != nil}
  /// Clears the value of `expenses`. Subsequent reads from it will return its default value.
  mutating func clearExpenses() {self._expenses = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _assets: String? = nil
  fileprivate var _liabilities: String? = nil
  fileprivate var _equity: String? = nil
  fileprivate var _income: String? = nil
  fileprivate var _expenses: String? = nil
}

/// Options that are visible to the user and that can be set.
/// Next token: 20
struct Beancount_Options_Options {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Root names of every account. This can be used to customize your category
  /// names, so that if you prefer "Revenue" over "Income" or "Capital" over
  /// "Equity", you can set them here. The account names in your input files
  /// must match, and the parser will validate these. You should place these
  /// options at the beginning of your file, because they affect how the parser
  /// recognizes account names.
  var accountTypes: Beancount_Options_AccountTypes {
    get {return _storage._accountTypes ?? Beancount_Options_AccountTypes()}
    set {_uniqueStorage()._accountTypes = newValue}
  }
  /// Returns true if `accountTypes` has been explicitly set.
  var hasAccountTypes: Bool {return _storage._accountTypes != nil}
  /// Clears the value of `accountTypes`. Subsequent reads from it will return its default value.
  mutating func clearAccountTypes() {_uniqueStorage()._accountTypes = nil}

  ///  The title of this ledger / input file. This shows up at the top of every
  ///  page. e.g. "Joe Smith's Personal Ledger".
  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  /// Leaf name of the equity account used for summarizing previous transactions
  /// into opening balances. e.g. "Opening-Balances".
  var accountPreviousBalances: String {
    get {return _storage._accountPreviousBalances ?? String()}
    set {_uniqueStorage()._accountPreviousBalances = newValue}
  }
  /// Returns true if `accountPreviousBalances` has been explicitly set.
  var hasAccountPreviousBalances: Bool {return _storage._accountPreviousBalances != nil}
  /// Clears the value of `accountPreviousBalances`. Subsequent reads from it will return its default value.
  mutating func clearAccountPreviousBalances() {_uniqueStorage()._accountPreviousBalances = nil}

  /// Leaf name of the equity account used for transferring previous retained
  /// earnings from income and expenses accrued before the beginning of the
  /// exercise into the balance sheet. e.g., "Earnings:Previous".
  var accountPreviousEarnings: String {
    get {return _storage._accountPreviousEarnings ?? String()}
    set {_uniqueStorage()._accountPreviousEarnings = newValue}
  }
  /// Returns true if `accountPreviousEarnings` has been explicitly set.
  var hasAccountPreviousEarnings: Bool {return _storage._accountPreviousEarnings != nil}
  /// Clears the value of `accountPreviousEarnings`. Subsequent reads from it will return its default value.
  mutating func clearAccountPreviousEarnings() {_uniqueStorage()._accountPreviousEarnings = nil}

  /// Leaf name of the equity account used for inserting conversions that will
  /// zero out remaining amounts due to transfers before the opening date. This
  /// will essentially "fixup" the basic accounting equation due to the errors
  /// that priced conversions introduce. e.g., "Conversions:Previous".
  var accountPreviousConversions: String {
    get {return _storage._accountPreviousConversions ?? String()}
    set {_uniqueStorage()._accountPreviousConversions = newValue}
  }
  /// Returns true if `accountPreviousConversions` has been explicitly set.
  var hasAccountPreviousConversions: Bool {return _storage._accountPreviousConversions != nil}
  /// Clears the value of `accountPreviousConversions`. Subsequent reads from it will return its default value.
  mutating func clearAccountPreviousConversions() {_uniqueStorage()._accountPreviousConversions = nil}

  /// Leaf name of the equity account used for transferring current retained
  /// earnings from income and expenses accrued during the current exercise into
  /// the balance sheet. This is most often called "Net Income". e.g.,
  /// "Earnings:Current".
  var accountCurrentEarnings: String {
    get {return _storage._accountCurrentEarnings ?? String()}
    set {_uniqueStorage()._accountCurrentEarnings = newValue}
  }
  /// Returns true if `accountCurrentEarnings` has been explicitly set.
  var hasAccountCurrentEarnings: Bool {return _storage._accountCurrentEarnings != nil}
  /// Clears the value of `accountCurrentEarnings`. Subsequent reads from it will return its default value.
  mutating func clearAccountCurrentEarnings() {_uniqueStorage()._accountCurrentEarnings = nil}

  /// Leaf name of the equity account used for inserting conversions that will
  /// zero out remaining amounts due to transfers during the exercise period.
  /// e.g., "Conversions:Current".
  var accountCurrentConversions: String {
    get {return _storage._accountCurrentConversions ?? String()}
    set {_uniqueStorage()._accountCurrentConversions = newValue}
  }
  /// Returns true if `accountCurrentConversions` has been explicitly set.
  var hasAccountCurrentConversions: Bool {return _storage._accountCurrentConversions != nil}
  /// Clears the value of `accountCurrentConversions`. Subsequent reads from it will return its default value.
  mutating func clearAccountCurrentConversions() {_uniqueStorage()._accountCurrentConversions = nil}

  /// The name of an account to be used to post unrealized gains to. This is used
  /// when making any kind of conversion from cost to price on a balance sheet
  /// (or any realization). The amount inserted - the difference between book
  /// value and market value - has to be posted to a gains account to keep the
  /// balance on the sheet. This has no effect on behavior, other than providing
  /// a configurable account name for such postings to occur. Its value should
  /// not include the root account (e.g., defaults to "Unrealized").
  var accountUnrealizedGains: String {
    get {return _storage._accountUnrealizedGains ?? String()}
    set {_uniqueStorage()._accountUnrealizedGains = newValue}
  }
  /// Returns true if `accountUnrealizedGains` has been explicitly set.
  var hasAccountUnrealizedGains: Bool {return _storage._accountUnrealizedGains != nil}
  /// Clears the value of `accountUnrealizedGains`. Subsequent reads from it will return its default value.
  mutating func clearAccountUnrealizedGains() {_uniqueStorage()._accountUnrealizedGains = nil}

  /// The name of an account to be used to post to and accumulate rounding error.
  /// This is unset and this feature is disabled by default; setting this value
  /// to an account name will automatically enable the addition of postings on
  /// all transactions that have a residual amount. e.g., "Rounding".
  var accountRounding: String {
    get {return _storage._accountRounding ?? String()}
    set {_uniqueStorage()._accountRounding = newValue}
  }
  /// Returns true if `accountRounding` has been explicitly set.
  var hasAccountRounding: Bool {return _storage._accountRounding != nil}
  /// Clears the value of `accountRounding`. Subsequent reads from it will return its default value.
  mutating func clearAccountRounding() {_uniqueStorage()._accountRounding = nil}

  /// The imaginary currency used to convert all units for conversions at a
  /// degenerate rate of zero. This can be any currency name that isn't used in
  /// the rest of the ledger. Choose something unique that makes sense in your
  /// language. e.g., "NOTHING".
  var conversionCurrency: String {
    get {return _storage._conversionCurrency ?? String()}
    set {_uniqueStorage()._conversionCurrency = newValue}
  }
  /// Returns true if `conversionCurrency` has been explicitly set.
  var hasConversionCurrency: Bool {return _storage._conversionCurrency != nil}
  /// Clears the value of `conversionCurrency`. Subsequent reads from it will return its default value.
  mutating func clearConversionCurrency() {_uniqueStorage()._conversionCurrency = nil}

  /// Precision for evaluating arithmetic computations and reducing them to
  /// decimal numbers.
  var decimalEvaluationPrecision: Int32 {
    get {return _storage._decimalEvaluationPrecision ?? 0}
    set {_uniqueStorage()._decimalEvaluationPrecision = newValue}
  }
  /// Returns true if `decimalEvaluationPrecision` has been explicitly set.
  var hasDecimalEvaluationPrecision: Bool {return _storage._decimalEvaluationPrecision != nil}
  /// Clears the value of `decimalEvaluationPrecision`. Subsequent reads from it will return its default value.
  mutating func clearDecimalEvaluationPrecision() {_uniqueStorage()._decimalEvaluationPrecision = nil}

  /// Explicit precision settings per currency or instrument pair. This is where
  /// the values set by the user are stored in the options. This setting was
  /// missing in v2 and is very useful: these override the automatically inferred
  /// precisions per currency. The expected format for the key is either a single
  /// currency ("USD") or a pair of currencies with a separating slash
  /// ("USD/HOOL"), and the value a valid decimal number (e.g. "0.01").
  var precision: Dictionary<String,String> {
    get {return _storage._precision}
    set {_uniqueStorage()._precision = newValue}
  }

  /// Mappings of currency to the tolerance used when it cannot be inferred
  /// automatically. The tolerance at hand is the one used for verifying (1)
  /// that transactions balance, (2) explicit balance checks from 'balance'
  /// directives balance, and (3) in the tolerance used for padding (from the
  /// 'pad' directive).
  ///
  /// The values must be strings in the following format:
  /// <currency>:<tolerance>
  /// for example, 'USD:0.005'.
  ///
  /// By default, the tolerance allowed for currencies without an inferred value
  /// is zero. As a special case, this value, that is, the fallback value used
  /// for all currencies without an explicit default can be overridden using the
  /// '*' currency, like this:  '*:0.5'. Used by itself, this last example sets
  /// the fallback tolerance as '0.5' for all currencies.
  ///
  /// For detailed documentation about how tolerances are handled, see this doc:
  /// http://furius.ca/beancount/doc/tolerances.
  ///
  /// e.g., "CHF:0.01".
  var inferredToleranceDefault: Dictionary<String,String> {
    get {return _storage._inferredToleranceDefault}
    set {_uniqueStorage()._inferredToleranceDefault = newValue}
  }

  /// A multiplier for inferred tolerance values.
  ///
  /// When the tolerance values aren't specified explicitly via the
  /// 'inferred_tolerance_default' option, the tolerance is inferred from the
  /// numbers in the input file. For example, if a transaction has posting with
  /// a value like '32.424 CAD', the tolerance for CAD will be inferred to be
  /// 0.001 times some multiplier. This is the muliplier value.
  ///
  /// We normally assume that the institution we're reproducing this posting
  /// from applies rounding, and so the default value for the multiplier is
  /// 0.5, that is, half of the smallest digit encountered.
  ///
  /// You can customize this multiplier by changing this option, typically
  /// expanding it to account for amounts slightly beyond the usual tolerance,
  /// for example, if you deal with institutions with bad of unexpected rounding
  /// behaviour.
  ///
  /// For detailed documentation about how tolerances are handled, see this doc:
  /// http://furius.ca/beancount/doc/tolerances
  ///
  /// e.g., "0.5"
  var inferredToleranceMultiplier: String {
    get {return _storage._inferredToleranceMultiplier ?? String()}
    set {_uniqueStorage()._inferredToleranceMultiplier = newValue}
  }
  /// Returns true if `inferredToleranceMultiplier` has been explicitly set.
  var hasInferredToleranceMultiplier: Bool {return _storage._inferredToleranceMultiplier != nil}
  /// Clears the value of `inferredToleranceMultiplier`. Subsequent reads from it will return its default value.
  mutating func clearInferredToleranceMultiplier() {_uniqueStorage()._inferredToleranceMultiplier = nil}

  /// Enable a feature that expands the maximum tolerance inferred on
  /// transactions to include values on cost currencies inferred by postings
  /// held at-cost or converted at price. Those postings can imply a tolerance
  /// value by multiplying the smallest digit of the unit by the cost or price
  /// value and taking half of that value.
  ///
  /// For example, if a posting has an amount of "2.345 RGAGX {45.00 USD}"
  /// attached to it, it implies a tolerance of 0.001 x 45.00 * M = 0.045 USD
  /// (where M is the inferred_tolerance_multiplier) and this is added to the
  /// mix to enlarge the tolerance allowed for units of USD on that transaction.
  /// All the normally inferred tolerances (see
  /// http://furius.ca/beancount/doc/tolerances) are still taken into account.
  /// Enabling this flag only makes the tolerances potentially wider.
  var inferToleranceFromCost: Bool {
    get {return _storage._inferToleranceFromCost ?? false}
    set {_uniqueStorage()._inferToleranceFromCost = newValue}
  }
  /// Returns true if `inferToleranceFromCost` has been explicitly set.
  var hasInferToleranceFromCost: Bool {return _storage._inferToleranceFromCost != nil}
  /// Clears the value of `inferToleranceFromCost`. Subsequent reads from it will return its default value.
  mutating func clearInferToleranceFromCost() {_uniqueStorage()._inferToleranceFromCost = nil}

  /// A list of directory, relative to the CWD, which should be searched
  /// recursively for document files. For the document files to be automatically
  /// found they must have the following filename format: YYYY-MM-DD.(.*). e.g.,
  /// "/path/to/your/documents/archive"
  var documents: [String] {
    get {return _storage._documents}
    set {_uniqueStorage()._documents = newValue}
  }

  /// A list of currencies that we single out during reporting and create
  /// dedicated columns for. This is used to indicate the main currencies that
  /// you work with in real life. (Refrain from listing all the possible
  /// currencies here, this is not what it is made for; just list the very
  /// principal currencies you use daily only.)
  ///
  /// Because our system is agnostic to any unit definition that occurs in the
  /// input file, we use this to display these values in table cells without
  /// their associated unit strings. This allows you to import the numbers in a
  /// spreadsheet (e.g, "101.00 USD" does not get parsed by a spreadsheet
  /// import, but "101.00" does).
  ///
  /// If you need to enter a list of operating currencies, you may input this
  /// option multiple times, that is, you repeat the entire directive once for
  /// each desired operating currency.
  ///
  /// e.g., "USD".
  var operatingCurrency: [String] {
    get {return _storage._operatingCurrency}
    set {_uniqueStorage()._operatingCurrency = newValue}
  }

  /// A boolean, true if the number formatting routines should output commas
  /// as thousand separators in numbers.
  var renderCommas: Bool {
    get {return _storage._renderCommas ?? false}
    set {_uniqueStorage()._renderCommas = newValue}
  }
  /// Returns true if `renderCommas` has been explicitly set.
  var hasRenderCommas: Bool {return _storage._renderCommas != nil}
  /// Clears the value of `renderCommas`. Subsequent reads from it will return its default value.
  mutating func clearRenderCommas() {_uniqueStorage()._renderCommas = nil}

  var pluginProcessingMode: Beancount_Options_Options.ProcessingMode {
    get {return _storage._pluginProcessingMode ?? .default}
    set {_uniqueStorage()._pluginProcessingMode = newValue}
  }
  /// Returns true if `pluginProcessingMode` has been explicitly set.
  var hasPluginProcessingMode: Bool {return _storage._pluginProcessingMode != nil}
  /// Clears the value of `pluginProcessingMode`. Subsequent reads from it will return its default value.
  mutating func clearPluginProcessingMode() {_uniqueStorage()._pluginProcessingMode = nil}

  /// The booking method to apply to ambiguous reductions of inventory lots.
  /// When a posting is matched against the contents of an account's inventory
  /// to reduce its contents and multiple lots match, the method dictates how
  /// this ambiguity is resolved. Methods include "STRICT" which raises an
  /// error, "FIFO" which selects the oldest lot, and "NONE" which allows any
  /// reduction to be added to the inventory despite the absence of a match
  /// (resulting in mixed inventories).
  ///
  /// See the following documents for details:
  /// http://furius.ca/beancount/doc/inventories
  /// http://furius.ca/beancount/doc/proposal-booking
  ///
  /// e.g., STRICT
  var bookingMethod: Beancount_Options_Booking {
    get {return _storage._bookingMethod ?? .unknown}
    set {_uniqueStorage()._bookingMethod = newValue}
  }
  /// Returns true if `bookingMethod` has been explicitly set.
  var hasBookingMethod: Bool {return _storage._bookingMethod != nil}
  /// Clears the value of `bookingMethod`. Subsequent reads from it will return its default value.
  mutating func clearBookingMethod() {_uniqueStorage()._bookingMethod = nil}

  /// A boolean, if true, prepend the directory name of the top-level file to
  /// the PYTHONPATH.
  var insertPythonpath: Bool {
    get {return _storage._insertPythonpath ?? false}
    set {_uniqueStorage()._insertPythonpath = newValue}
  }
  /// Returns true if `insertPythonpath` has been explicitly set.
  var hasInsertPythonpath: Bool {return _storage._insertPythonpath != nil}
  /// Clears the value of `insertPythonpath`. Subsequent reads from it will return its default value.
  mutating func clearInsertPythonpath() {_uniqueStorage()._insertPythonpath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A string that defines which set of plugins is to be run by the loader: if
  /// the mode is "default", a preset list of plugins are automatically run
  /// before any user plugin. If the mode is "raw", no preset plugins are run at
  /// all, only user plugins are run (the user should explicitly load the desired
  /// list of plugins by using the 'plugin' option. This is useful in case the
  /// user wants full control over the ordering in which the plugins are run).
  enum ProcessingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case raw // = 1

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .raw
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .raw: return 1
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Beancount_Options_Options.ProcessingMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Beancount_Options_Booking: @unchecked Sendable {}
extension Beancount_Options_ProcessingInfo: @unchecked Sendable {}
extension Beancount_Options_ProcessingInfo.Plugin: @unchecked Sendable {}
extension Beancount_Options_AccountTypes: @unchecked Sendable {}
extension Beancount_Options_Options: @unchecked Sendable {}
extension Beancount_Options_Options.ProcessingMode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "beancount.options"

extension Beancount_Options_Booking: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "STRICT"),
    2: .same(proto: "STRICT_WITH_SIZE"),
    3: .same(proto: "NONE"),
    4: .same(proto: "AVERAGE"),
    5: .same(proto: "FIFO"),
    6: .same(proto: "LIFO"),
  ]
}

extension Beancount_Options_ProcessingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "include"),
    3: .standard(proto: "input_hash"),
    4: .standard(proto: "precision_stats"),
    5: .same(proto: "commodities"),
    6: .same(proto: "plugin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.include) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._inputHash) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._precisionStats) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.commodities) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.plugin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.include.isEmpty {
      try visitor.visitRepeatedStringField(value: self.include, fieldNumber: 2)
    }
    try { if let v = self._inputHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._precisionStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.commodities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.commodities, fieldNumber: 5)
    }
    if !self.plugin.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.plugin, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Options_ProcessingInfo, rhs: Beancount_Options_ProcessingInfo) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs.include != rhs.include {return false}
    if lhs._inputHash != rhs._inputHash {return false}
    if lhs._precisionStats != rhs._precisionStats {return false}
    if lhs.commodities != rhs.commodities {return false}
    if lhs.plugin != rhs.plugin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Options_ProcessingInfo.Plugin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Beancount_Options_ProcessingInfo.protoMessageName + ".Plugin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Options_ProcessingInfo.Plugin, rhs: Beancount_Options_ProcessingInfo.Plugin) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Options_AccountTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTypes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
    2: .same(proto: "liabilities"),
    3: .same(proto: "equity"),
    4: .same(proto: "income"),
    5: .same(proto: "expenses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._assets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._liabilities) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._equity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._income) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._expenses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assets {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._liabilities {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._equity {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._income {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expenses {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Options_AccountTypes, rhs: Beancount_Options_AccountTypes) -> Bool {
    if lhs._assets != rhs._assets {return false}
    if lhs._liabilities != rhs._liabilities {return false}
    if lhs._equity != rhs._equity {return false}
    if lhs._income != rhs._income {return false}
    if lhs._expenses != rhs._expenses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Options_Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Options"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_types"),
    6: .same(proto: "title"),
    7: .standard(proto: "account_previous_balances"),
    8: .standard(proto: "account_previous_earnings"),
    9: .standard(proto: "account_previous_conversions"),
    10: .standard(proto: "account_current_earnings"),
    11: .standard(proto: "account_current_conversions"),
    12: .standard(proto: "account_unrealized_gains"),
    13: .standard(proto: "account_rounding"),
    14: .standard(proto: "conversion_currency"),
    24: .standard(proto: "decimal_evaluation_precision"),
    25: .same(proto: "precision"),
    15: .standard(proto: "inferred_tolerance_default"),
    16: .standard(proto: "inferred_tolerance_multiplier"),
    17: .standard(proto: "infer_tolerance_from_cost"),
    18: .same(proto: "documents"),
    19: .standard(proto: "operating_currency"),
    20: .standard(proto: "render_commas"),
    21: .standard(proto: "plugin_processing_mode"),
    22: .standard(proto: "booking_method"),
    23: .standard(proto: "insert_pythonpath"),
  ]

  fileprivate class _StorageClass {
    var _accountTypes: Beancount_Options_AccountTypes? = nil
    var _title: String? = nil
    var _accountPreviousBalances: String? = nil
    var _accountPreviousEarnings: String? = nil
    var _accountPreviousConversions: String? = nil
    var _accountCurrentEarnings: String? = nil
    var _accountCurrentConversions: String? = nil
    var _accountUnrealizedGains: String? = nil
    var _accountRounding: String? = nil
    var _conversionCurrency: String? = nil
    var _decimalEvaluationPrecision: Int32? = nil
    var _precision: Dictionary<String,String> = [:]
    var _inferredToleranceDefault: Dictionary<String,String> = [:]
    var _inferredToleranceMultiplier: String? = nil
    var _inferToleranceFromCost: Bool? = nil
    var _documents: [String] = []
    var _operatingCurrency: [String] = []
    var _renderCommas: Bool? = nil
    var _pluginProcessingMode: Beancount_Options_Options.ProcessingMode? = nil
    var _bookingMethod: Beancount_Options_Booking? = nil
    var _insertPythonpath: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountTypes = source._accountTypes
      _title = source._title
      _accountPreviousBalances = source._accountPreviousBalances
      _accountPreviousEarnings = source._accountPreviousEarnings
      _accountPreviousConversions = source._accountPreviousConversions
      _accountCurrentEarnings = source._accountCurrentEarnings
      _accountCurrentConversions = source._accountCurrentConversions
      _accountUnrealizedGains = source._accountUnrealizedGains
      _accountRounding = source._accountRounding
      _conversionCurrency = source._conversionCurrency
      _decimalEvaluationPrecision = source._decimalEvaluationPrecision
      _precision = source._precision
      _inferredToleranceDefault = source._inferredToleranceDefault
      _inferredToleranceMultiplier = source._inferredToleranceMultiplier
      _inferToleranceFromCost = source._inferToleranceFromCost
      _documents = source._documents
      _operatingCurrency = source._operatingCurrency
      _renderCommas = source._renderCommas
      _pluginProcessingMode = source._pluginProcessingMode
      _bookingMethod = source._bookingMethod
      _insertPythonpath = source._insertPythonpath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._accountTypes) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._accountPreviousBalances) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._accountPreviousEarnings) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._accountPreviousConversions) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._accountCurrentEarnings) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._accountCurrentConversions) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._accountUnrealizedGains) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._accountRounding) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._conversionCurrency) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._inferredToleranceDefault) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._inferredToleranceMultiplier) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._inferToleranceFromCost) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._documents) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._operatingCurrency) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._renderCommas) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._pluginProcessingMode) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._bookingMethod) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._insertPythonpath) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._decimalEvaluationPrecision) }()
        case 25: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._precision) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._accountTypes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._accountPreviousBalances {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._accountPreviousEarnings {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._accountPreviousConversions {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._accountCurrentEarnings {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._accountCurrentConversions {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._accountUnrealizedGains {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._accountRounding {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._conversionCurrency {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      if !_storage._inferredToleranceDefault.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._inferredToleranceDefault, fieldNumber: 15)
      }
      try { if let v = _storage._inferredToleranceMultiplier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._inferToleranceFromCost {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      if !_storage._documents.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._documents, fieldNumber: 18)
      }
      if !_storage._operatingCurrency.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._operatingCurrency, fieldNumber: 19)
      }
      try { if let v = _storage._renderCommas {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._pluginProcessingMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._bookingMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._insertPythonpath {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._decimalEvaluationPrecision {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
      } }()
      if !_storage._precision.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._precision, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Options_Options, rhs: Beancount_Options_Options) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountTypes != rhs_storage._accountTypes {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._accountPreviousBalances != rhs_storage._accountPreviousBalances {return false}
        if _storage._accountPreviousEarnings != rhs_storage._accountPreviousEarnings {return false}
        if _storage._accountPreviousConversions != rhs_storage._accountPreviousConversions {return false}
        if _storage._accountCurrentEarnings != rhs_storage._accountCurrentEarnings {return false}
        if _storage._accountCurrentConversions != rhs_storage._accountCurrentConversions {return false}
        if _storage._accountUnrealizedGains != rhs_storage._accountUnrealizedGains {return false}
        if _storage._accountRounding != rhs_storage._accountRounding {return false}
        if _storage._conversionCurrency != rhs_storage._conversionCurrency {return false}
        if _storage._decimalEvaluationPrecision != rhs_storage._decimalEvaluationPrecision {return false}
        if _storage._precision != rhs_storage._precision {return false}
        if _storage._inferredToleranceDefault != rhs_storage._inferredToleranceDefault {return false}
        if _storage._inferredToleranceMultiplier != rhs_storage._inferredToleranceMultiplier {return false}
        if _storage._inferToleranceFromCost != rhs_storage._inferToleranceFromCost {return false}
        if _storage._documents != rhs_storage._documents {return false}
        if _storage._operatingCurrency != rhs_storage._operatingCurrency {return false}
        if _storage._renderCommas != rhs_storage._renderCommas {return false}
        if _storage._pluginProcessingMode != rhs_storage._pluginProcessingMode {return false}
        if _storage._bookingMethod != rhs_storage._bookingMethod {return false}
        if _storage._insertPythonpath != rhs_storage._insertPythonpath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Options_Options.ProcessingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "RAW"),
  ]
}
