// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: beancount/cparser/inter.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// -*- mode: protobuf -*-
//
// Schemas for messages that are specific to Beancount's parser output. These
// are only used for the intermediate state of the parsed data, merely
// representing the production of the parser, before the subsequent processing
// (booking) that will produce the finalized directives.
//
// The data structures seen here are not visible in the final output nor to the
// regular plugins, which see the resolved ones produced after booking and
// interpolation.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Operators of expressions.
enum Beancount_Inter_ExprOp: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case num // = 0
  case add // = 1
  case sub // = 2
  case mul // = 3
  case div // = 4

  /// Unary
  case neg // = 5

  /// Unary
  case plus // = 6
  case paren // = 7

  init() {
    self = .num
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .num
    case 1: self = .add
    case 2: self = .sub
    case 3: self = .mul
    case 4: self = .div
    case 5: self = .neg
    case 6: self = .plus
    case 7: self = .paren
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .num: return 0
    case .add: return 1
    case .sub: return 2
    case .mul: return 3
    case .div: return 4
    case .neg: return 5
    case .plus: return 6
    case .paren: return 7
    }
  }

}

#if swift(>=4.2)

extension Beancount_Inter_ExprOp: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Arithmetic expressions to be evaluated later with Decimal context.
struct Beancount_Inter_Expr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which operator this represents in the tree.
  var op: Beancount_Inter_ExprOp {
    get {return _storage._op ?? .num}
    set {_uniqueStorage()._op = newValue}
  }
  /// Returns true if `op` has been explicitly set.
  var hasOp: Bool {return _storage._op != nil}
  /// Clears the value of `op`. Subsequent reads from it will return its default value.
  mutating func clearOp() {_uniqueStorage()._op = nil}

  /// Terminal value for 'NUM'.
  var number: Beancount_Number {
    get {return _storage._number ?? Beancount_Number()}
    set {_uniqueStorage()._number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return _storage._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {_uniqueStorage()._number = nil}

  /// Binary arguments.
  var arg1: Beancount_Inter_Expr {
    get {return _storage._arg1 ?? Beancount_Inter_Expr()}
    set {_uniqueStorage()._arg1 = newValue}
  }
  /// Returns true if `arg1` has been explicitly set.
  var hasArg1: Bool {return _storage._arg1 != nil}
  /// Clears the value of `arg1`. Subsequent reads from it will return its default value.
  mutating func clearArg1() {_uniqueStorage()._arg1 = nil}

  var arg2: Beancount_Inter_Expr {
    get {return _storage._arg2 ?? Beancount_Inter_Expr()}
    set {_uniqueStorage()._arg2 = newValue}
  }
  /// Returns true if `arg2` has been explicitly set.
  var hasArg2: Bool {return _storage._arg2 != nil}
  /// Clears the value of `arg2`. Subsequent reads from it will return its default value.
  mutating func clearArg2() {_uniqueStorage()._arg2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A pair of a number or expression.
struct Beancount_Inter_ExprNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: Beancount_Number {
    get {return _number ?? Beancount_Number()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var expr: Beancount_Inter_Expr {
    get {return _expr ?? Beancount_Inter_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  mutating func clearExpr() {self._expr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: Beancount_Number? = nil
  fileprivate var _expr: Beancount_Inter_Expr? = nil
}

/// A container for all the parser specs produced on a posting.
/// These are the objects that directly represent the parsed input yet to be
/// interpolated and booked.
struct Beancount_Inter_Spec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A UnitSpec instance.
  var units: Beancount_Inter_UnitSpec {
    get {return _storage._units ?? Beancount_Inter_UnitSpec()}
    set {_uniqueStorage()._units = newValue}
  }
  /// Returns true if `units` has been explicitly set.
  var hasUnits: Bool {return _storage._units != nil}
  /// Clears the value of `units`. Subsequent reads from it will return its default value.
  mutating func clearUnits() {_uniqueStorage()._units = nil}

  /// A CostSpec instance. Warning: This partically filled field is only used in
  /// the production of the intermediate representation produced by the parser
  /// and never set in the final processed output from Beancount. Do not use
  /// this.
  var cost: Beancount_Inter_CostSpec {
    get {return _storage._cost ?? Beancount_Inter_CostSpec()}
    set {_uniqueStorage()._cost = newValue}
  }
  /// Returns true if `cost` has been explicitly set.
  var hasCost: Bool {return _storage._cost != nil}
  /// Clears the value of `cost`. Subsequent reads from it will return its default value.
  mutating func clearCost() {_uniqueStorage()._cost = nil}

  /// A PriceSpec instance.
  var price: Beancount_Inter_PriceSpec {
    get {return _storage._price ?? Beancount_Inter_PriceSpec()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {_uniqueStorage()._price = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A unit specification. This is like `Amount`, except that either the number or
/// currency can be missing.
struct Beancount_Inter_UnitSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Finalized value in 'number' and original expression in 'expr'.
  var number: Beancount_Number {
    get {return _number ?? Beancount_Number()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var expr: Beancount_Inter_Expr {
    get {return _expr ?? Beancount_Inter_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  mutating func clearExpr() {self._expr = nil}

  /// The unit currency for the enclosing posting.
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: Beancount_Number? = nil
  fileprivate var _expr: Beancount_Inter_Expr? = nil
  fileprivate var _currency: String? = nil
}

/// A price specification. This is similar to `Amount`, except that either the
/// number or currency can be missing.
struct Beancount_Inter_PriceSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Finalized value in 'number' and original expression in 'expr'.
  var number: Beancount_Number {
    get {return _number ?? Beancount_Number()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var expr: Beancount_Inter_Expr {
    get {return _expr ?? Beancount_Inter_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  mutating func clearExpr() {self._expr = nil}

  /// The quote currency for the enclosing posting.
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  /// A flag that determines whether the expression above refers to a per-unit
  /// price or a total price, yet to be calculated.
  var isTotal: Bool {
    get {return _isTotal ?? false}
    set {_isTotal = newValue}
  }
  /// Returns true if `isTotal` has been explicitly set.
  var hasIsTotal: Bool {return self._isTotal != nil}
  /// Clears the value of `isTotal`. Subsequent reads from it will return its default value.
  mutating func clearIsTotal() {self._isTotal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: Beancount_Number? = nil
  fileprivate var _expr: Beancount_Inter_Expr? = nil
  fileprivate var _currency: String? = nil
  fileprivate var _isTotal: Bool? = nil
}

/// A cost specification, which still requires to be filled in, and the final
/// per-unit numbers be calculated. This gets translated to Cost after booking
/// and interpolation.
struct Beancount_Inter_CostSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A decimal number, exclusive the per-unit cost.
  var perUnit: Beancount_Inter_ExprNumber {
    get {return _storage._perUnit ?? Beancount_Inter_ExprNumber()}
    set {_uniqueStorage()._perUnit = newValue}
  }
  /// Returns true if `perUnit` has been explicitly set.
  var hasPerUnit: Bool {return _storage._perUnit != nil}
  /// Clears the value of `perUnit`. Subsequent reads from it will return its default value.
  mutating func clearPerUnit() {_uniqueStorage()._perUnit = nil}

  /// A decimal number, the total cost/price.
  var total: Beancount_Inter_ExprNumber {
    get {return _storage._total ?? Beancount_Inter_ExprNumber()}
    set {_uniqueStorage()._total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  var hasTotal: Bool {return _storage._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  mutating func clearTotal() {_uniqueStorage()._total = nil}

  /// A string, the commodity of the cost.
  var currency: String {
    get {return _storage._currency ?? String()}
    set {_uniqueStorage()._currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return _storage._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {_uniqueStorage()._currency = nil}

  /// A datetime.date for the date that the lot was created at. There should
  /// always be a valid date.
  var date: Beancount_Date {
    get {return _storage._date ?? Beancount_Date()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  /// A string for the label of this lot, or None, if there is no label.
  var label: String {
    get {return _storage._label ?? String()}
    set {_uniqueStorage()._label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return _storage._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {_uniqueStorage()._label = nil}

  /// A flag explicitly indicating to merge all matching lots and compute the
  /// average cost.
  var mergeCost: Bool {
    get {return _storage._mergeCost ?? false}
    set {_uniqueStorage()._mergeCost = newValue}
  }
  /// Returns true if `mergeCost` has been explicitly set.
  var hasMergeCost: Bool {return _storage._mergeCost != nil}
  /// Clears the value of `mergeCost`. Subsequent reads from it will return its default value.
  mutating func clearMergeCost() {_uniqueStorage()._mergeCost = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Beancount_Inter_ExprOp: @unchecked Sendable {}
extension Beancount_Inter_Expr: @unchecked Sendable {}
extension Beancount_Inter_ExprNumber: @unchecked Sendable {}
extension Beancount_Inter_Spec: @unchecked Sendable {}
extension Beancount_Inter_UnitSpec: @unchecked Sendable {}
extension Beancount_Inter_PriceSpec: @unchecked Sendable {}
extension Beancount_Inter_CostSpec: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "beancount.inter"

extension Beancount_Inter_ExprOp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NUM"),
    1: .same(proto: "ADD"),
    2: .same(proto: "SUB"),
    3: .same(proto: "MUL"),
    4: .same(proto: "DIV"),
    5: .same(proto: "NEG"),
    6: .same(proto: "PLUS"),
    7: .same(proto: "PAREN"),
  ]
}

extension Beancount_Inter_Expr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Expr"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "number"),
    3: .same(proto: "arg1"),
    4: .same(proto: "arg2"),
  ]

  fileprivate class _StorageClass {
    var _op: Beancount_Inter_ExprOp? = nil
    var _number: Beancount_Number? = nil
    var _arg1: Beancount_Inter_Expr? = nil
    var _arg2: Beancount_Inter_Expr? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _op = source._op
      _number = source._number
      _arg1 = source._arg1
      _arg2 = source._arg2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._number, !v.isInitialized {return false}
      if let v = _storage._arg1, !v.isInitialized {return false}
      if let v = _storage._arg2, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._op) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._number) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._arg1) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._arg2) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._op {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._number {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._arg1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._arg2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_Expr, rhs: Beancount_Inter_Expr) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._op != rhs_storage._op {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._arg1 != rhs_storage._arg1 {return false}
        if _storage._arg2 != rhs_storage._arg2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Inter_ExprNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExprNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "expr"),
  ]

  public var isInitialized: Bool {
    if let v = self._number, !v.isInitialized {return false}
    if let v = self._expr, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_ExprNumber, rhs: Beancount_Inter_ExprNumber) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._expr != rhs._expr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Inter_Spec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Spec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .same(proto: "units"),
    9: .same(proto: "cost"),
    10: .same(proto: "price"),
  ]

  fileprivate class _StorageClass {
    var _units: Beancount_Inter_UnitSpec? = nil
    var _cost: Beancount_Inter_CostSpec? = nil
    var _price: Beancount_Inter_PriceSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _units = source._units
      _cost = source._cost
      _price = source._price
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._units, !v.isInitialized {return false}
      if let v = _storage._cost, !v.isInitialized {return false}
      if let v = _storage._price, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._units) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._cost) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._units {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._cost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_Spec, rhs: Beancount_Inter_Spec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._units != rhs_storage._units {return false}
        if _storage._cost != rhs_storage._cost {return false}
        if _storage._price != rhs_storage._price {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Inter_UnitSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnitSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "expr"),
    3: .same(proto: "currency"),
  ]

  public var isInitialized: Bool {
    if let v = self._number, !v.isInitialized {return false}
    if let v = self._expr, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_UnitSpec, rhs: Beancount_Inter_UnitSpec) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._expr != rhs._expr {return false}
    if lhs._currency != rhs._currency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Inter_PriceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "expr"),
    3: .same(proto: "currency"),
    4: .standard(proto: "is_total"),
  ]

  public var isInitialized: Bool {
    if let v = self._number, !v.isInitialized {return false}
    if let v = self._expr, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isTotal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isTotal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_PriceSpec, rhs: Beancount_Inter_PriceSpec) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._expr != rhs._expr {return false}
    if lhs._currency != rhs._currency {return false}
    if lhs._isTotal != rhs._isTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Inter_CostSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CostSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "per_unit"),
    2: .same(proto: "total"),
    3: .same(proto: "currency"),
    4: .same(proto: "date"),
    5: .same(proto: "label"),
    6: .standard(proto: "merge_cost"),
  ]

  fileprivate class _StorageClass {
    var _perUnit: Beancount_Inter_ExprNumber? = nil
    var _total: Beancount_Inter_ExprNumber? = nil
    var _currency: String? = nil
    var _date: Beancount_Date? = nil
    var _label: String? = nil
    var _mergeCost: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _perUnit = source._perUnit
      _total = source._total
      _currency = source._currency
      _date = source._date
      _label = source._label
      _mergeCost = source._mergeCost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._perUnit, !v.isInitialized {return false}
      if let v = _storage._total, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._perUnit) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._total) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._label) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._mergeCost) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._perUnit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._total {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._currency {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._label {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._mergeCost {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Inter_CostSpec, rhs: Beancount_Inter_CostSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._perUnit != rhs_storage._perUnit {return false}
        if _storage._total != rhs_storage._total {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._mergeCost != rhs_storage._mergeCost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
