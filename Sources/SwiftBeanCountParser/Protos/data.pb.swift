// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: beancount/ccore/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// -*- mode: protobuf -*-
//
// A schema for Beancount's fully booked stream of directives. These are the
// definitions of the API and main artifact produced by the Beancount core, a
// stream of directives.
//
// Note: Unlike in Beancount 2.x, the messages representing the intermediate
// parsed state (the AST) are defined and located elsewhere.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A metadata value. This is a simple general variant type intended to keep the
/// values of the metadata key-value pairs.
struct Beancount_MetaValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Beancount_MetaValue.OneOf_Value? = nil

  var text: String {
    get {
      if case .text(let v)? = value {return v}
      return String()
    }
    set {value = .text(newValue)}
  }

  var account: String {
    get {
      if case .account(let v)? = value {return v}
      return String()
    }
    set {value = .account(newValue)}
  }

  var currency: String {
    get {
      if case .currency(let v)? = value {return v}
      return String()
    }
    set {value = .currency(newValue)}
  }

  var tag: String {
    get {
      if case .tag(let v)? = value {return v}
      return String()
    }
    set {value = .tag(newValue)}
  }

  var link: String {
    get {
      if case .link(let v)? = value {return v}
      return String()
    }
    set {value = .link(newValue)}
  }

  var flag: String {
    get {
      if case .flag(let v)? = value {return v}
      return String()
    }
    set {value = .flag(newValue)}
  }

  var date: Beancount_Date {
    get {
      if case .date(let v)? = value {return v}
      return Beancount_Date()
    }
    set {value = .date(newValue)}
  }

  var boolean: Bool {
    get {
      if case .boolean(let v)? = value {return v}
      return false
    }
    set {value = .boolean(newValue)}
  }

  var integer: Int64 {
    get {
      if case .integer(let v)? = value {return v}
      return 0
    }
    set {value = .integer(newValue)}
  }

  var number: Beancount_Number {
    get {
      if case .number(let v)? = value {return v}
      return Beancount_Number()
    }
    set {value = .number(newValue)}
  }

  var amount: Beancount_Amount {
    get {
      if case .amount(let v)? = value {return v}
      return Beancount_Amount()
    }
    set {value = .amount(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case text(String)
    case account(String)
    case currency(String)
    case tag(String)
    case link(String)
    case flag(String)
    case date(Beancount_Date)
    case boolean(Bool)
    case integer(Int64)
    case number(Beancount_Number)
    case amount(Beancount_Amount)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .number: return {
        guard case .number(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .amount: return {
        guard case .amount(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: Beancount_MetaValue.OneOf_Value, rhs: Beancount_MetaValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.account, .account): return {
        guard case .account(let l) = lhs, case .account(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.currency, .currency): return {
        guard case .currency(let l) = lhs, case .currency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tag, .tag): return {
        guard case .tag(let l) = lhs, case .tag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.link, .link): return {
        guard case .link(let l) = lhs, case .link(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flag, .flag): return {
        guard case .flag(let l) = lhs, case .flag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolean, .boolean): return {
        guard case .boolean(let l) = lhs, case .boolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integer, .integer): return {
        guard case .integer(let l) = lhs, case .integer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.number, .number): return {
        guard case .number(let l) = lhs, case .number(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.amount, .amount): return {
        guard case .amount(let l) = lhs, case .amount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A metadata dictionary, or key-value pairs.
struct Beancount_Meta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kv: [Beancount_Meta.KV] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct KV {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var value: Beancount_MetaValue {
      get {return _value ?? Beancount_MetaValue()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: String? = nil
    fileprivate var _value: Beancount_MetaValue? = nil
  }

  init() {}
}

/// An 'Amount' represents a number of a particular unit of something. It's
/// essentially a typed number, with corresponding manipulation operations
/// defined on it.
struct Beancount_Amount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: Beancount_Number {
    get {return _number ?? Beancount_Number()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  /// Intermediate parsed expressions before resolution.
  ///
  /// WARNING: The following fields is only used in the production of the
  /// intermediate representation produced by the parser and are never set in the
  /// final processed output from Beancount. This is never set in the finalized
  /// interpolated and booked data.
  var expr: Beancount_Inter_Expr {
    get {return _expr ?? Beancount_Inter_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  mutating func clearExpr() {self._expr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: Beancount_Number? = nil
  fileprivate var _currency: String? = nil
  fileprivate var _expr: Beancount_Inter_Expr? = nil
}

/// A variant of Amount that also includes a date and a label.
struct Beancount_Cost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A decimal number, the per-unit cost.
  var number: Beancount_Number {
    get {return _number ?? Beancount_Number()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  /// A string, the cost currency.
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  /// A datetime.date for the date that the lot was created at. There should
  /// always be a valid date.
  var date: Beancount_Date {
    get {return _date ?? Beancount_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  /// A string for the label of this lot, or None, if there is no label.
  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: Beancount_Number? = nil
  fileprivate var _currency: String? = nil
  fileprivate var _date: Beancount_Date? = nil
  fileprivate var _label: String? = nil
}

/// A Position is a pair of units and optional cost. This is used to represent
/// lots accumulated over time in inventories, and the impact of posting on an
/// inventory is also a position. It is synonymous with a "lot."
struct Beancount_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Amount, the number of units and its currency.
  var units: Beancount_Amount {
    get {return _storage._units ?? Beancount_Amount()}
    set {_uniqueStorage()._units = newValue}
  }
  /// Returns true if `units` has been explicitly set.
  var hasUnits: Bool {return _storage._units != nil}
  /// Clears the value of `units`. Subsequent reads from it will return its default value.
  mutating func clearUnits() {_uniqueStorage()._units = nil}

  /// An optional Cost that stores the cost basis and lot identification.
  var cost: Beancount_Cost {
    get {return _storage._cost ?? Beancount_Cost()}
    set {_uniqueStorage()._cost = newValue}
  }
  /// Returns true if `cost` has been explicitly set.
  var hasCost: Bool {return _storage._cost != nil}
  /// Clears the value of `cost`. Subsequent reads from it will return its default value.
  mutating func clearCost() {_uniqueStorage()._cost = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Postings are contained in Transaction entries. These represent the individual
/// legs of a transaction. Note: a posting may only appear within a single entry
/// (multiple transactions may not share a Posting instance), and that's what the
/// entry field should be set to.
struct Beancount_Posting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of the posting.
  var location: Beancount_Location {
    get {return _storage._location ?? Beancount_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// A dict of strings to values, the metadata that was attached specifically to
  /// that posting, or None, if not provided. In practice, most of the instances
  /// will be unlikely to have metadata.
  var meta: Beancount_Meta {
    get {return _storage._meta ?? Beancount_Meta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {_uniqueStorage()._meta = nil}

  /// Optional posting date.
  var date: Beancount_Date {
    get {return _storage._date ?? Beancount_Date()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  /// An optional flag, a one-character string or None, which is to be associated
  /// with the posting. Most postings don't have a flag, but it can be convenient
  /// to mark a particular posting as problematic or pending to be reconciled for
  /// a future import of its account.
  var flag: Data {
    get {return _storage._flag ?? Data()}
    set {_uniqueStorage()._flag = newValue}
  }
  /// Returns true if `flag` has been explicitly set.
  var hasFlag: Bool {return _storage._flag != nil}
  /// Clears the value of `flag`. Subsequent reads from it will return its default value.
  mutating func clearFlag() {_uniqueStorage()._flag = nil}

  /// A string, the account that is modified by this posting.
  var account: String {
    get {return _storage._account ?? String()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// The position this posting impacts on its inventory.
  var position: Beancount_Position {
    get {return _storage._position ?? Beancount_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// An Amount, the price at which the position took place, or None, where not
  /// relevant. Providing a price member to a posting automatically adds a price
  /// in the prices database at the date of the transaction.
  var price: Beancount_Amount {
    get {return _storage._price ?? Beancount_Amount()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {_uniqueStorage()._price = nil}

  /// Intermediate parsed expressions before resolution.
  ///
  /// WARNING: The following fields is only used in the production of the
  /// intermediate representation produced by the parser and are never set in the
  /// final processed output from Beancount. This is never set in the finalized
  /// interpolated and booked data.
  var spec: Beancount_Inter_Spec {
    get {return _storage._spec ?? Beancount_Inter_Spec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A pair of a Posting and its parent Transaction. This is inserted as
/// temporaries in lists of postings-of-entries, which is the product of a
/// realization.
struct Beancount_TxnPosting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txn: Beancount_Transaction {
    get {return _txn ?? Beancount_Transaction()}
    set {_txn = newValue}
  }
  /// Returns true if `txn` has been explicitly set.
  var hasTxn: Bool {return self._txn != nil}
  /// Clears the value of `txn`. Subsequent reads from it will return its default value.
  mutating func clearTxn() {self._txn = nil}

  var posting: Beancount_Posting {
    get {return _posting ?? Beancount_Posting()}
    set {_posting = newValue}
  }
  /// Returns true if `posting` has been explicitly set.
  var hasPosting: Bool {return self._posting != nil}
  /// Clears the value of `posting`. Subsequent reads from it will return its default value.
  mutating func clearPosting() {self._posting = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _txn: Beancount_Transaction? = nil
  fileprivate var _posting: Beancount_Posting? = nil
}

/// A transaction! This is the main type of object that we manipulate, and the
/// entire reason this whole project exists in the first place, because
/// representing these types of structures with a spreadsheet is difficult.
struct Beancount_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A single-character string or None. This user-specified string represents
  /// some custom/user-defined state of the transaction. You can use this for
  /// various purposes. Otherwise common, pre-defined flags are defined under
  /// beancount.core.flags, to flags transactions that are automatically
  /// generated.
  var flag: Data {
    get {return _flag ?? Data()}
    set {_flag = newValue}
  }
  /// Returns true if `flag` has been explicitly set.
  var hasFlag: Bool {return self._flag != nil}
  /// Clears the value of `flag`. Subsequent reads from it will return its default value.
  mutating func clearFlag() {self._flag = nil}

  /// A free-form string that identifies the payee, or None, if absent.
  var payee: String {
    get {return _payee ?? String()}
    set {_payee = newValue}
  }
  /// Returns true if `payee` has been explicitly set.
  var hasPayee: Bool {return self._payee != nil}
  /// Clears the value of `payee`. Subsequent reads from it will return its default value.
  mutating func clearPayee() {self._payee = nil}

  /// A free-form string that provides a description for the transaction. All
  /// transactions have at least a narration string, this is never None.
  var narration: String {
    get {return _narration ?? String()}
    set {_narration = newValue}
  }
  /// Returns true if `narration` has been explicitly set.
  var hasNarration: Bool {return self._narration != nil}
  /// Clears the value of `narration`. Subsequent reads from it will return its default value.
  mutating func clearNarration() {self._narration = nil}

  /// A list of Posting instances, the legs of this transaction. See the
  /// doc under Posting above.
  var postings: [Beancount_Posting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flag: Data? = nil
  fileprivate var _payee: String? = nil
  fileprivate var _narration: String? = nil
}

/// An "open account" directive.
struct Beancount_Open {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the name of the account that is being opened.
  var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// A list of strings, currencies that are allowed in this account. May be
  /// None, in which case it means that there are no restrictions on which
  /// currencies may be stored in this account.
  var currencies: [String] = []

  /// A Booking enum, the booking method to use to disambiguate postings to this
  /// account (when zero or more than one postings match the specification), or
  /// None if not specified. In practice, this attribute will be should be left
  /// unspecified (None) in the vast majority of cases. See Booking below for a
  /// selection of valid methods.
  var booking: Beancount_Options_Booking {
    get {return _booking ?? .unknown}
    set {_booking = newValue}
  }
  /// Returns true if `booking` has been explicitly set.
  var hasBooking: Bool {return self._booking != nil}
  /// Clears the value of `booking`. Subsequent reads from it will return its default value.
  mutating func clearBooking() {self._booking = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: String? = nil
  fileprivate var _booking: Beancount_Options_Booking? = nil
}

/// A "close account" directive.
struct Beancount_Close {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the name of the account that is being closed.
  var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: String? = nil
}

/// An optional commodity declaration directive. Commodities generally do not
/// need to be declared, but they may, and this is mainly created as intended to
/// be used to attach meta-data on a commodity name. Whenever a plugin needs
/// per-commodity meta-data, you would define such a commodity directive. Another
/// use is to define a commodity that isn't otherwise (yet) used anywhere in an
/// input file. (At the moment the date is meaningless but is specified for
/// coherence with all the other directives; if you can think of a good use case,
/// let us know).
struct Beancount_Commodity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the commodity under consideration.
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currency: String? = nil
}

/// A "pad this account with this other account" directive. This directive
/// automatically inserts transactions that will make the next chronological
/// balance directive succeeds. It can be used to fill in missing date ranges of
/// transactions, as a convenience. You don't have to use this, it's sugar coating
/// in case you need it, while you're entering past history into your Ledger.
struct Beancount_Pad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the name of the account which needs to be filled.
  var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// A string, the name of the account which is used to debit from in order to
  /// fill 'account'.
  var sourceAccount: String {
    get {return _sourceAccount ?? String()}
    set {_sourceAccount = newValue}
  }
  /// Returns true if `sourceAccount` has been explicitly set.
  var hasSourceAccount: Bool {return self._sourceAccount != nil}
  /// Clears the value of `sourceAccount`. Subsequent reads from it will return its default value.
  mutating func clearSourceAccount() {self._sourceAccount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: String? = nil
  fileprivate var _sourceAccount: String? = nil
}

/// A "check the balance of this account" directive. This directive asserts that
/// the declared account should have a known number of units of a particular
/// currency at the beginning of its date. This is essentially an assertion, and
/// corresponds to the final "Statement Balance" line of a real-world statement.
/// These assertions act as checkpoints to help ensure that you have entered your
/// transactions correctly.
struct Beancount_Balance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the account whose balance to check at the given date.
  var account: String {
    get {return _storage._account ?? String()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// An Amount, the number of units of the given currency you're expecting
  /// 'account' to have at this date.
  var amount: Beancount_Amount {
    get {return _storage._amount ?? Beancount_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// A Decimal object, the amount of tolerance to use in the verification.
  var tolerance: Beancount_Number {
    get {return _storage._tolerance ?? Beancount_Number()}
    set {_uniqueStorage()._tolerance = newValue}
  }
  /// Returns true if `tolerance` has been explicitly set.
  var hasTolerance: Bool {return _storage._tolerance != nil}
  /// Clears the value of `tolerance`. Subsequent reads from it will return its default value.
  mutating func clearTolerance() {_uniqueStorage()._tolerance = nil}

  /// None if the balance check succeeds. This value is set to the difference if
  /// the balance fails.
  var difference: Beancount_Number {
    get {return _storage._difference ?? Beancount_Number()}
    set {_uniqueStorage()._difference = newValue}
  }
  /// Returns true if `difference` has been explicitly set.
  var hasDifference: Bool {return _storage._difference != nil}
  /// Clears the value of `difference`. Subsequent reads from it will return its default value.
  mutating func clearDifference() {_uniqueStorage()._difference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A note directive, a general note that is attached to an account. These are
/// used to attach text at a particular date in a specific account. The notes can
/// be anything; a typical use would be to jot down an answer from a phone call
/// to the institution represented by the account. It should show up in an
/// account's journal. If you don't want this rendered, use the comment syntax in
/// the input file, which does not get parsed and stored.
struct Beancount_Note {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the account which the note is to be attached to. This is never
  /// None, notes always have an account they correspond to.
  var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// A free-form string, the text of the note. This can be long if you want it
  /// to.
  var comment: String {
    get {return _comment ?? String()}
    set {_comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  var hasComment: Bool {return self._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  mutating func clearComment() {self._comment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: String? = nil
  fileprivate var _comment: String? = nil
}

/// An "event value change" directive. These directives are used as string
/// variables that have different values over time. You can use these to track an
/// address, your location, your current employer, anything you like. The kind of
/// reporting that is made of these generic events is based on days and a
/// timeline. For instance, if you need to track the number of days you spend in
/// each country or state, create a "location" event and whenever you travel, add
/// an event directive to indicate its new value. You should be able to write
/// simple scripts against those in order to compute if you were present
/// somewhere for a particular number of days. Here's an illustrative example
/// usage, in order to maintain your health insurance coverage in Canada, you
/// need to be present in the country for 183 days or more, excluding trips of
/// less than 30 days. There is a similar test to be done in the US by aliens to
/// figure out if they need to be considered as residents for tax purposes (the
/// so-called "substantial presence test"). By integrating these directives into
/// your bookkeeping, you can easily have a little program that computes the
/// tests for you. This is, of course, entirely optional and somewhat auxiliary
/// to the main purpose of double-entry bookkeeping, but correlates strongly with
/// the transactions you insert in it, and so it's a really convenient thing to
/// have in the same input file.
struct Beancount_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A short string, typically a single lowercase word, that defines a unique
  /// variable whose value changes over time. For example, 'location'.
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// A free-form string, the value of the variable as of the date of the
  /// transaction.
  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: String? = nil
  fileprivate var _description_p: String? = nil
}

/// A named query declaration. This directive is used to create pre-canned
/// queries that can then be automatically run or made available to the shell, or
/// perhaps be rendered as part of a web interface. The purpose of this routine
/// is to define useful queries for the context of the particular given Beancount
/// input file.
///
/// The date is the date at which this query should be run. All directives
/// following this date will be ignored automatically. This is essentially
/// equivalent to the CLOSE modifier in the shell syntax.
struct Beancount_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the unique identifier for the query.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The SQL query string to be run or made available.
  var queryString: String {
    get {return _queryString ?? String()}
    set {_queryString = newValue}
  }
  /// Returns true if `queryString` has been explicitly set.
  var hasQueryString: Bool {return self._queryString != nil}
  /// Clears the value of `queryString`. Subsequent reads from it will return its default value.
  mutating func clearQueryString() {self._queryString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _queryString: String? = nil
}

/// A price declaration directive. This establishes the price of a currency in
/// terms of another currency as of the directive's date. A history of the prices
/// for each currency pairs is built and can be queried within the bookkeeping
/// system. Note that because Beancount does not store any data at time-of-day
/// resolution, it makes no sense to have multiple price directives at the same
/// date. (Beancount will not attempt to solve this problem; this is beyond the
/// general scope of double-entry bookkeeping and if you need to build a day
/// trading system, you should probably use something else).
struct Beancount_Price {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the currency that is being priced, e.g. HOOL.
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  /// An instance of Amount, the number of units and currency that 'currency' is
  /// worth, for instance 1200.12 USD.
  var amount: Beancount_Amount {
    get {return _amount ?? Beancount_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currency: String? = nil
  fileprivate var _amount: Beancount_Amount? = nil
}

/// A document file declaration directive. This directive is used to attach a
/// statement to an account, at a particular date. A typical usage would be to
/// render PDF files or scans of your bank statements into the account's journal.
/// While you can explicitly create those directives in the input syntax, it is
/// much more convenient to provide Beancount with a root directory to search for
/// filenames in a hierarchy mirroring the chart of accounts, filenames which
/// should match the following dated format: "YYYY-MM-DD.*". See options for
/// detail. Beancount will automatically create these documents directives based
/// on the file hierarchy, and you can get them by parsing the list of entries.
struct Beancount_Document {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string, the account which the statement or document is associated with.
  var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The absolute filename of the document file.
  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: String? = nil
  fileprivate var _filename: String? = nil
}

/// A custom directive. This directive can be used to implement new experimental
/// dated features in the Beancount file. This is meant as an intermediate
/// measure to be used when you would need to implement a new directive in a
/// plugin. These directives will be parsed liberally... any list of tokens are
/// supported. All that is required is some unique name for them that acts as a
/// "type". These directives are included in the stream and a plugin should be
/// able to gather them.
struct Beancount_Custom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string that represents the type of the directive.
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// A list of values of various simple types supported by the grammar. (Note
  /// that this list is not enforced to be consistent for all directives of the
  /// same type by the parser.)
  var values: [Beancount_MetaValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: String? = nil
}

/// A valid directive type. The result of parsing a Beancount file is a sorted
/// stream of directives, ordered by date.
///
/// Directives may be of multiple types. The most important type of directive in
/// the stream is a Transaction and a lot of the processing functions work only
/// on those (and filter them out of the stream). All the other directives
/// present in the input file are also included in the stream. Processing
/// functions and plugins can extract those and implement corresponding
/// functionality.
struct Beancount_Directive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location (filename and lime number) where the directive was parsed from.
  var location: Beancount_Location {
    get {return _storage._location ?? Beancount_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Date associated with the directive. This is not optional; all directives
  /// have a valid date. Beancount does not consider time, only dates. The line
  /// where the directive shows up in the file is used as a secondary sort key
  /// beyond the date.
  var date: Beancount_Date {
    get {return _storage._date ?? Beancount_Date()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  /// A dict of strings to objects, potentially attached to each of the directive
  /// types. The values may be strings, account names, tags, dates, numbers,
  /// amounts and currencies. There are two special attributes which are always
  /// present on all directives: 'filename' and 'lineno'.
  var meta: Beancount_Meta {
    get {return _storage._meta ?? Beancount_Meta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {_uniqueStorage()._meta = nil}

  /// An optional set of unique tag strings (without the '#').
  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// An optional set of unique link strings (without the '^').
  var links: [String] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// The type specialization.
  var body: OneOf_Body? {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  var transaction: Beancount_Transaction {
    get {
      if case .transaction(let v)? = _storage._body {return v}
      return Beancount_Transaction()
    }
    set {_uniqueStorage()._body = .transaction(newValue)}
  }

  var price: Beancount_Price {
    get {
      if case .price(let v)? = _storage._body {return v}
      return Beancount_Price()
    }
    set {_uniqueStorage()._body = .price(newValue)}
  }

  var balance: Beancount_Balance {
    get {
      if case .balance(let v)? = _storage._body {return v}
      return Beancount_Balance()
    }
    set {_uniqueStorage()._body = .balance(newValue)}
  }

  var `open`: Beancount_Open {
    get {
      if case .open(let v)? = _storage._body {return v}
      return Beancount_Open()
    }
    set {_uniqueStorage()._body = .open(newValue)}
  }

  var close: Beancount_Close {
    get {
      if case .close(let v)? = _storage._body {return v}
      return Beancount_Close()
    }
    set {_uniqueStorage()._body = .close(newValue)}
  }

  var commodity: Beancount_Commodity {
    get {
      if case .commodity(let v)? = _storage._body {return v}
      return Beancount_Commodity()
    }
    set {_uniqueStorage()._body = .commodity(newValue)}
  }

  var pad: Beancount_Pad {
    get {
      if case .pad(let v)? = _storage._body {return v}
      return Beancount_Pad()
    }
    set {_uniqueStorage()._body = .pad(newValue)}
  }

  var document: Beancount_Document {
    get {
      if case .document(let v)? = _storage._body {return v}
      return Beancount_Document()
    }
    set {_uniqueStorage()._body = .document(newValue)}
  }

  var note: Beancount_Note {
    get {
      if case .note(let v)? = _storage._body {return v}
      return Beancount_Note()
    }
    set {_uniqueStorage()._body = .note(newValue)}
  }

  var event: Beancount_Event {
    get {
      if case .event(let v)? = _storage._body {return v}
      return Beancount_Event()
    }
    set {_uniqueStorage()._body = .event(newValue)}
  }

  var query: Beancount_Query {
    get {
      if case .query(let v)? = _storage._body {return v}
      return Beancount_Query()
    }
    set {_uniqueStorage()._body = .query(newValue)}
  }

  var custom: Beancount_Custom {
    get {
      if case .custom(let v)? = _storage._body {return v}
      return Beancount_Custom()
    }
    set {_uniqueStorage()._body = .custom(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type specialization.
  enum OneOf_Body: Equatable {
    case transaction(Beancount_Transaction)
    case price(Beancount_Price)
    case balance(Beancount_Balance)
    case `open`(Beancount_Open)
    case close(Beancount_Close)
    case commodity(Beancount_Commodity)
    case pad(Beancount_Pad)
    case document(Beancount_Document)
    case note(Beancount_Note)
    case event(Beancount_Event)
    case query(Beancount_Query)
    case custom(Beancount_Custom)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .transaction: return {
        guard case .transaction(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .price: return {
        guard case .price(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .balance: return {
        guard case .balance(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .custom: return {
        guard case .custom(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: Beancount_Directive.OneOf_Body, rhs: Beancount_Directive.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.price, .price): return {
        guard case .price(let l) = lhs, case .price(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.balance, .balance): return {
        guard case .balance(let l) = lhs, case .balance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.open, .open): return {
        guard case .open(let l) = lhs, case .open(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.close, .close): return {
        guard case .close(let l) = lhs, case .close(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commodity, .commodity): return {
        guard case .commodity(let l) = lhs, case .commodity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pad, .pad): return {
        guard case .pad(let l) = lhs, case .pad(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.document, .document): return {
        guard case .document(let l) = lhs, case .document(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.note, .note): return {
        guard case .note(let l) = lhs, case .note(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A location in an input file. This represents a span of lines.
struct Beancount_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An absolute filename path.
  ///
  /// TODO(blais): Change this to an index to the short list of filenames
  /// involved from ProcessingInfo. Make index 0 the special "no file" index for
  /// generated directives.
  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  /// The beginning line number.
  var lineno: Int32 {
    get {return _lineno ?? 0}
    set {_lineno = newValue}
  }
  /// Returns true if `lineno` has been explicitly set.
  var hasLineno: Bool {return self._lineno != nil}
  /// Clears the value of `lineno`. Subsequent reads from it will return its default value.
  mutating func clearLineno() {self._lineno = nil}

  /// An optional ending line number.
  var linenoEnd: Int32 {
    get {return _linenoEnd ?? 0}
    set {_linenoEnd = newValue}
  }
  /// Returns true if `linenoEnd` has been explicitly set.
  var hasLinenoEnd: Bool {return self._linenoEnd != nil}
  /// Clears the value of `linenoEnd`. Subsequent reads from it will return its default value.
  mutating func clearLinenoEnd() {self._linenoEnd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _lineno: Int32? = nil
  fileprivate var _linenoEnd: Int32? = nil
}

/// An error in processing.
struct Beancount_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The error message.
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Location where the error occurred in the file, if relevant. The line
  /// numbers are optional and may be left unset if not relevant to the context.
  var location: Beancount_Location {
    get {return _location ?? Beancount_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  /// A unique hash referencing of a corresponding directive.
  var dirhash: String {
    get {return _dirhash ?? String()}
    set {_dirhash = newValue}
  }
  /// Returns true if `dirhash` has been explicitly set.
  var hasDirhash: Bool {return self._dirhash != nil}
  /// Clears the value of `dirhash`. Subsequent reads from it will return its default value.
  mutating func clearDirhash() {self._dirhash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: String? = nil
  fileprivate var _location: Beancount_Location? = nil
  fileprivate var _dirhash: String? = nil
}

/// Container for a list of directives and more infos.
struct Beancount_LedgerProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var directives: [Beancount_Directive] = []

  var errors: [Beancount_Error] = []

  var options: Beancount_Options_Options {
    get {return _options ?? Beancount_Options_Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var info: Beancount_Options_ProcessingInfo {
    get {return _info ?? Beancount_Options_ProcessingInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _options: Beancount_Options_Options? = nil
  fileprivate var _info: Beancount_Options_ProcessingInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Beancount_MetaValue: @unchecked Sendable {}
extension Beancount_MetaValue.OneOf_Value: @unchecked Sendable {}
extension Beancount_Meta: @unchecked Sendable {}
extension Beancount_Meta.KV: @unchecked Sendable {}
extension Beancount_Amount: @unchecked Sendable {}
extension Beancount_Cost: @unchecked Sendable {}
extension Beancount_Position: @unchecked Sendable {}
extension Beancount_Posting: @unchecked Sendable {}
extension Beancount_TxnPosting: @unchecked Sendable {}
extension Beancount_Transaction: @unchecked Sendable {}
extension Beancount_Open: @unchecked Sendable {}
extension Beancount_Close: @unchecked Sendable {}
extension Beancount_Commodity: @unchecked Sendable {}
extension Beancount_Pad: @unchecked Sendable {}
extension Beancount_Balance: @unchecked Sendable {}
extension Beancount_Note: @unchecked Sendable {}
extension Beancount_Event: @unchecked Sendable {}
extension Beancount_Query: @unchecked Sendable {}
extension Beancount_Price: @unchecked Sendable {}
extension Beancount_Document: @unchecked Sendable {}
extension Beancount_Custom: @unchecked Sendable {}
extension Beancount_Directive: @unchecked Sendable {}
extension Beancount_Directive.OneOf_Body: @unchecked Sendable {}
extension Beancount_Location: @unchecked Sendable {}
extension Beancount_Error: @unchecked Sendable {}
extension Beancount_LedgerProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "beancount"

extension Beancount_MetaValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetaValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "account"),
    3: .same(proto: "currency"),
    4: .same(proto: "tag"),
    5: .same(proto: "link"),
    6: .same(proto: "flag"),
    7: .same(proto: "date"),
    8: .same(proto: "boolean"),
    9: .same(proto: "integer"),
    10: .same(proto: "number"),
    11: .same(proto: "amount"),
  ]

  public var isInitialized: Bool {
    if let v = self.value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .text(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .account(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .currency(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .tag(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .link(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .flag(v)
        }
      }()
      case 7: try {
        var v: Beancount_Date?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .date(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolean(v)
        }
      }()
      case 9: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integer(v)
        }
      }()
      case 10: try {
        var v: Beancount_Number?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .number(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .number(v)
        }
      }()
      case 11: try {
        var v: Beancount_Amount?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .amount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .amount(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .account?: try {
      guard case .account(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .currency?: try {
      guard case .currency(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .tag?: try {
      guard case .tag(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .link?: try {
      guard case .link(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .flag?: try {
      guard case .flag(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
    }()
    case .number?: try {
      guard case .number(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .amount?: try {
      guard case .amount(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_MetaValue, rhs: Beancount_MetaValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Meta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kv"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.kv) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kv.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kv, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Meta, rhs: Beancount_Meta) -> Bool {
    if lhs.kv != rhs.kv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Meta.KV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Beancount_Meta.protoMessageName + ".KV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Meta.KV, rhs: Beancount_Meta.KV) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "currency"),
    3: .same(proto: "expr"),
  ]

  public var isInitialized: Bool {
    if let v = self._number, !v.isInitialized {return false}
    if let v = self._expr, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Amount, rhs: Beancount_Amount) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._currency != rhs._currency {return false}
    if lhs._expr != rhs._expr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Cost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cost"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "currency"),
    3: .same(proto: "date"),
    4: .same(proto: "label"),
  ]

  public var isInitialized: Bool {
    if let v = self._number, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Cost, rhs: Beancount_Cost) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._currency != rhs._currency {return false}
    if lhs._date != rhs._date {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "units"),
    2: .same(proto: "cost"),
  ]

  fileprivate class _StorageClass {
    var _units: Beancount_Amount? = nil
    var _cost: Beancount_Cost? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _units = source._units
      _cost = source._cost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._units, !v.isInitialized {return false}
      if let v = _storage._cost, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._units) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cost) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._units {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Position, rhs: Beancount_Position) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._units != rhs_storage._units {return false}
        if _storage._cost != rhs_storage._cost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Posting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Posting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "meta"),
    3: .same(proto: "date"),
    4: .same(proto: "flag"),
    5: .same(proto: "account"),
    6: .same(proto: "position"),
    7: .same(proto: "price"),
    8: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _location: Beancount_Location? = nil
    var _meta: Beancount_Meta? = nil
    var _date: Beancount_Date? = nil
    var _flag: Data? = nil
    var _account: String? = nil
    var _position: Beancount_Position? = nil
    var _price: Beancount_Amount? = nil
    var _spec: Beancount_Inter_Spec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _location = source._location
      _meta = source._meta
      _date = source._date
      _flag = source._flag
      _account = source._account
      _position = source._position
      _price = source._price
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._meta, !v.isInitialized {return false}
      if let v = _storage._position, !v.isInitialized {return false}
      if let v = _storage._price, !v.isInitialized {return false}
      if let v = _storage._spec, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._flag) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._account) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._price) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._flag {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._account {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Posting, rhs: Beancount_Posting) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._location != rhs_storage._location {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._flag != rhs_storage._flag {return false}
        if _storage._account != rhs_storage._account {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_TxnPosting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxnPosting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txn"),
    2: .same(proto: "posting"),
  ]

  public var isInitialized: Bool {
    if let v = self._txn, !v.isInitialized {return false}
    if let v = self._posting, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._txn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._posting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._txn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._posting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_TxnPosting, rhs: Beancount_TxnPosting) -> Bool {
    if lhs._txn != rhs._txn {return false}
    if lhs._posting != rhs._posting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flag"),
    2: .same(proto: "payee"),
    3: .same(proto: "narration"),
    4: .same(proto: "postings"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.postings) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._flag) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._payee) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._narration) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.postings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flag {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._payee {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._narration {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.postings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postings, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Transaction, rhs: Beancount_Transaction) -> Bool {
    if lhs._flag != rhs._flag {return false}
    if lhs._payee != rhs._payee {return false}
    if lhs._narration != rhs._narration {return false}
    if lhs.postings != rhs.postings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Open: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Open"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "currencies"),
    3: .same(proto: "booking"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.currencies) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._booking) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.currencies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.currencies, fieldNumber: 2)
    }
    try { if let v = self._booking {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Open, rhs: Beancount_Open) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.currencies != rhs.currencies {return false}
    if lhs._booking != rhs._booking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Close: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Close"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Close, rhs: Beancount_Close) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Commodity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Commodity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Commodity, rhs: Beancount_Commodity) -> Bool {
    if lhs._currency != rhs._currency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Pad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pad"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "source_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sourceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sourceAccount {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Pad, rhs: Beancount_Pad) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._sourceAccount != rhs._sourceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Balance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "amount"),
    3: .same(proto: "tolerance"),
    4: .same(proto: "difference"),
  ]

  fileprivate class _StorageClass {
    var _account: String? = nil
    var _amount: Beancount_Amount? = nil
    var _tolerance: Beancount_Number? = nil
    var _difference: Beancount_Number? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _amount = source._amount
      _tolerance = source._tolerance
      _difference = source._difference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount, !v.isInitialized {return false}
      if let v = _storage._tolerance, !v.isInitialized {return false}
      if let v = _storage._difference, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._account) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._amount) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tolerance) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._difference) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._account {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tolerance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._difference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Balance, rhs: Beancount_Balance) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._tolerance != rhs_storage._tolerance {return false}
        if _storage._difference != rhs_storage._difference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Note"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._comment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Note, rhs: Beancount_Note) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._comment != rhs._comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Event, rhs: Beancount_Event) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "query_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._queryString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._queryString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Query, rhs: Beancount_Query) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._queryString != rhs._queryString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Price: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Price"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .same(proto: "amount"),
  ]

  public var isInitialized: Bool {
    if let v = self._amount, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Price, rhs: Beancount_Price) -> Bool {
    if lhs._currency != rhs._currency {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Document"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Document, rhs: Beancount_Document) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._filename != rhs._filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Custom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Custom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "values"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.values) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Custom, rhs: Beancount_Custom) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Directive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Directive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "date"),
    3: .same(proto: "meta"),
    4: .same(proto: "tags"),
    5: .same(proto: "links"),
    6: .same(proto: "transaction"),
    7: .same(proto: "price"),
    8: .same(proto: "balance"),
    9: .same(proto: "open"),
    10: .same(proto: "close"),
    11: .same(proto: "commodity"),
    12: .same(proto: "pad"),
    13: .same(proto: "document"),
    14: .same(proto: "note"),
    15: .same(proto: "event"),
    16: .same(proto: "query"),
    17: .same(proto: "custom"),
  ]

  fileprivate class _StorageClass {
    var _location: Beancount_Location? = nil
    var _date: Beancount_Date? = nil
    var _meta: Beancount_Meta? = nil
    var _tags: [String] = []
    var _links: [String] = []
    var _body: Beancount_Directive.OneOf_Body?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _location = source._location
      _date = source._date
      _meta = source._meta
      _tags = source._tags
      _links = source._links
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._meta, !v.isInitialized {return false}
      if let v = _storage._body, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._links) }()
        case 6: try {
          var v: Beancount_Transaction?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .transaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .transaction(v)
          }
        }()
        case 7: try {
          var v: Beancount_Price?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .price(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .price(v)
          }
        }()
        case 8: try {
          var v: Beancount_Balance?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .balance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .balance(v)
          }
        }()
        case 9: try {
          var v: Beancount_Open?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .open(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .open(v)
          }
        }()
        case 10: try {
          var v: Beancount_Close?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .close(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .close(v)
          }
        }()
        case 11: try {
          var v: Beancount_Commodity?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .commodity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .commodity(v)
          }
        }()
        case 12: try {
          var v: Beancount_Pad?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .pad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .pad(v)
          }
        }()
        case 13: try {
          var v: Beancount_Document?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .document(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .document(v)
          }
        }()
        case 14: try {
          var v: Beancount_Note?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .note(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .note(v)
          }
        }()
        case 15: try {
          var v: Beancount_Event?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .event(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .event(v)
          }
        }()
        case 16: try {
          var v: Beancount_Query?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .query(v)
          }
        }()
        case 17: try {
          var v: Beancount_Custom?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .custom(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .custom(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 4)
      }
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._links, fieldNumber: 5)
      }
      switch _storage._body {
      case .transaction?: try {
        guard case .transaction(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .price?: try {
        guard case .price(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .balance?: try {
        guard case .balance(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .open?: try {
        guard case .open(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .close?: try {
        guard case .close(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .commodity?: try {
        guard case .commodity(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .pad?: try {
        guard case .pad(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .document?: try {
        guard case .document(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .note?: try {
        guard case .note(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .event?: try {
        guard case .event(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .query?: try {
        guard case .query(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .custom?: try {
        guard case .custom(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Directive, rhs: Beancount_Directive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._location != rhs_storage._location {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "lineno"),
    3: .standard(proto: "lineno_end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._lineno) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._linenoEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lineno {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._linenoEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Location, rhs: Beancount_Location) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._lineno != rhs._lineno {return false}
    if lhs._linenoEnd != rhs._linenoEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "location"),
    3: .same(proto: "dirhash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._dirhash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dirhash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_Error, rhs: Beancount_Error) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs._location != rhs._location {return false}
    if lhs._dirhash != rhs._dirhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Beancount_LedgerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LedgerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directives"),
    2: .same(proto: "errors"),
    3: .same(proto: "options"),
    4: .same(proto: "info"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.directives) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.directives) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.directives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directives, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Beancount_LedgerProto, rhs: Beancount_LedgerProto) -> Bool {
    if lhs.directives != rhs.directives {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs._options != rhs._options {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
